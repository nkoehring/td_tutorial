Bling Bling a.k.a. EXPLOSIONS!
==============================

Now to the step everyone waited for (I guess?): Graphic effects like explosions
([particles](http://craftyjs.com/api/Particles.html)) and animations ([tweening](http://craftyjs.com/api/Tween.html))!

Unfortunately these topics are not exactly simple…

Eeny, tweeny, miny, moe
-----------------------

For now, only the console (and from time to time disappearing enemies) indicate
that the towers are firing and enemies are hit.

When a tower shoots, it should somehow show that. At the same time, it would be
great to see it somehow reloading. As a simple solution, the towers colour
could change: From darkgreen to normal green when the tower is ready to shoot.
When shooting, the tower could flash into yellow and then quickly move back to
half-green. Lets see, how this works.

To change an objects value over time, so called tweening is used. Crafty
luckily offers a [component](http://craftyjs.com/api/Tween.html) for that, so
that the EnterFrame-Count-And-Change game doesn't have to be done on our own.

But it doesn't allow us to animate colours. The documentation states, only the
attributes `x`, `y`, `w`, `h`, `rotation` and `alpha` are supported. Okay, fair
enough: to get a dark green, the alpha value can be set.

Lets start by defining the desired values in `./components/tower.js`:

```js
Crafty.c("Tower", {
  required: "2D, Canvas, Color, Draggable, Delay, Tween",  // added the Tween component

  // …

  init () {
    this.w = 15
    this.h = 15
    this.strength = 1
    this.range = 2
    this.reloadTime = 500
    this.alpha_ready = 1.0          // alpha value when ready
    this.alpha_empty = 0.5          // alpha value after shot

    this.color("#00FF00")
    this.alpha = this.alpha_empty   // tower is empty after being built
    this.delay(() => { this.aimAndShoot() }, this.reloadTime, -1)
  },

  // …
```

As you can see, the tower will not be loaded from the beginning. This is a
matter of taste but this way is also good for testing the first tweening:

```js
  init () {
    // …
    this.color("#00FF00")
    this.alpha = this.alpha_empty   // tower is empty after being built

    this.tween({alpha: this.alpha_ready}, this.reloadTime*0.8, "linear")
    this.delay(() => { this.aimAndShoot() }, this.reloadTime, -1)
  },
  // …
```

This changes the colour right after initialising the tower. Good and simple
enough. The animation should be a bit shorter than the actual reload time, to
make sure, it is really finished before the next shot is fired. This also
"feels" better.

Now to the colour change after firing:

```js
  // …
  aimAndShoot () {
    let tower = this

    Crafty("Enemy").each(function(i) {
      const enemy = this
      const distance = Crafty.math.distance(enemy.x, enemy.y, tower.x, tower.y)

      if (distance < tower.range * 20) {
        Crafty.log("Fire!")
        enemy.hit(tower.strength)

        tower.alpha = tower.alpha_empty
        tower.tween({alpha: tower.alpha_ready}, tower.reloadTime*0.8, "linear")
      }
    })
  },
  // …
```

Do you see some duplication here, that would fit well in its own little
function? If the answer is yes: Very good! Lets move the tween call into a
separate function called `reload`. This helps when one day, the animation will
be altered and moves knowledge out of the aimAndShoot function – why should it
know how to reload?

```js
  // …
  reload () {
    this.tween({alpha: this.alpha_ready}, this.reloadTime*0.8, "linear")
  },
  // …
```

And the two tween calls should be exchanged by `this.reload()` in the init
function and `tower.reload()` in the aimAndShoot function respectively.

Flash! Ahaaa! Savior of the universe!
-------------------------------------

I'm a big fan of Queen but apart from that, the tower should also flash when
shooting. We cannot use tweening for colours, so we might leave this without
animation and use delays instead.

First, we need some more variables, to keep things tidy:

```js
  init () {
    // …
    this.original_color = "#00FF00" // the actual tower colour
    this.flash_color = "#AAFF00"    // the colour while shooting

    this.color(this.original_color)
    // …
  },
```

Now the idea is, to set the flash colour right before shooting and resetting it
right afterwards. Humans comfortably see changes of 50-100ms. Everything
shorter would probably not be visible enough.

The reload function uses 80% of the actual reload time, which is 400ms. So lets
use the left-over time:

```js
  aimAndShoot () {
    let tower = this

    Crafty("Enemy").each(function(i) {
      const enemy = this
      const distance = Crafty.math.distance(enemy.x, enemy.y, tower.x, tower.y)

      if (distance < tower.range * 20) {
        Crafty.log("Fire!")

        tower.color(tower.flash_color)        // Flash! A-aaa!
        enemy.hit(tower.strength)

        tower.delay(() => {
          tower.color(tower.original_color)   // set back to normal colour,
          tower.alpha = tower.alpha_empty     // unloaded state
          tower.reload()                      // and reload
        }, tower.reloadTime*0.2, 0)           // after 100ms
      }
    })
  }
```

